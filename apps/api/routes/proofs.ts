import { Router } from 'express';
import { eq } from 'drizzle-orm';
import { db } from '../db.js';
import { formConfigs, credentialTemplates } from '@shared/schema';
import { verifier, type ProofRequestDefinition } from '../../../packages/external/orbit/VerifierClient.js';

const router = Router();

interface FieldRequirement {
  templateId: string;
  attribute: string;
  required: boolean;
  credDefId: string;
  issuerDid: string;
}

// Helper function to build requirements from a form
async function buildRequirements(formId: number): Promise<FieldRequirement[]> {
  // Get the form configuration
  const [form] = await db
    .select()
    .from(formConfigs)
    .where(eq(formConfigs.id, formId));

  if (!form) {
    throw new Error('Form not found');
  }

  const requirements: FieldRequirement[] = [];
  const formSchema = form.formSchema as any;
  const metadata = form.metadata as any;

  // Process each component in the form schema
  if (formSchema?.components) {
    for (const component of formSchema.components) {
      const fieldKey = component.key;
      const fieldMetadata = metadata?.fields?.[fieldKey];

      // Check both component properties and field metadata for VC mapping
      const componentVcMapping = component.properties?.vcMapping;
      const metadataVcMapping = fieldMetadata?.vcMapping;
      const vcMapping = componentVcMapping || metadataVcMapping;

      // Check both component properties and field metadata for data source and credential mode
      const componentDataSource = component.properties?.dataSource;
      const metadataDataSource = fieldMetadata?.type;
      const dataSource = componentDataSource || metadataDataSource;

      const componentCredentialMode = component.properties?.credentialMode;
      const metadataCredentialMode = fieldMetadata?.credentialMode;
      const credentialMode = componentCredentialMode || metadataCredentialMode || 'optional';

      // Only process verified credential fields
      if ((dataSource === 'verified' || metadataDataSource === 'verified') && vcMapping) {
        const { credentialType, attributeName } = vcMapping;
        const isRequired = component.validate?.required || credentialMode === 'required';

        console.log('Processing VC field:', {
          fieldKey,
          credentialType,
          attributeName,
          credentialMode,
          isRequired
        });

        // Find the credential template by label
        const [template] = await db
          .select()
          .from(credentialTemplates)
          .where(eq(credentialTemplates.label, credentialType));

        if (template) {
          console.log('Found matching template:', template.label);
          requirements.push({
            templateId: credentialType,
            attribute: attributeName,
            required: isRequired,
            credDefId: template.credDefId,
            issuerDid: template.issuerDid
          });
        } else {
          console.log('No template found for:', credentialType);
        }
      }
    }
  }

  return requirements;
}

// Helper function to create Orbit proof definition
function makeOrbitDefinition(requirements: FieldRequirement[], formId: number): ProofRequestDefinition {
  const timestamp = Date.now();
  
  const requestedAttributes = requirements.map(req => ({
    name: req.attribute,
    restrictions: [{
      cred_def_id: req.credDefId,
      issuer_did: req.issuerDid
    }],
    non_revoked: { from: 0, to: 0 }
  }));

  return {
    proofName: `vcfb::${formId}::${timestamp}`,
    proofVersion: "1.0",
    comment: "Proof request auto-generated by VC Form Builder",
    requestedAttributes,
    requestedPredicates: []
  };
}

// Initialize proof request
router.post('/init', async (req, res) => {
  try {
    const { formId } = req.body;
    
    if (!formId) {
      return res.status(400).json({ error: 'formId is required' });
    }

    // Build requirements from the form
    const requirements = await buildRequirements(formId);
    
    if (requirements.length === 0) {
      return res.status(400).json({ error: 'No VC fields found in form' });
    }

    // Create Orbit proof definition
    const payload = makeOrbitDefinition(requirements, formId);
    
    // Call Orbit to define the proof request
    const { proofRequestId } = await verifier.defineProof(payload);
    
    res.json({ proofRequestId });
  } catch (error: any) {
    console.error('Proof initialization error:', error);
    res.status(500).json({ error: error.message || 'Failed to initialize proof request' });
  }
});

// QR code cache with 5-minute TTL
const cache = new Map<string, { qrSvg: string; inviteUrl: string; ts: number }>();
const TTL = 5 * 60 * 1000; // 5 minutes

// Get QR code for proof request
router.get('/:id/qr', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check cache first
    const cached = cache.get(id);
    if (cached && Date.now() - cached.ts < TTL) {
      console.log(`Returning cached QR for proof request: ${id}`);
      return res.json({ qrSvg: cached.qrSvg, inviteUrl: cached.inviteUrl });
    }

    // Call Orbit to prepare URL and get QR code
    console.log(`Generating QR for proof request: ${id}`);
    const qr = await verifier.prepareUrl(id);
    
    // Cache the result
    cache.set(id, { ...qr, ts: Date.now() });
    
    res.json(qr);
  } catch (error: any) {
    console.error('Prepare URL error:', error.response?.status, await error.response?.text?.());
    
    if (error.response?.status === 404) {
      return res.status(404).json({ error: 'Proof request expired or not found' });
    }
    
    res.status(502).json({ error: 'Orbit prepare-url failed' });
  }
});

export default router;